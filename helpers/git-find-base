#!/usr/bin/perl
#
# Copyright 2014 Intel Corporation
# Author: Jacob Keller
# License: GPLv2
#
# Find the most recent commit that a given mbox (*with* index information!) can
# apply, assuming that our tree has the blobs available. Passes all options
# directly to git-log, so you can shorten or filter what commits to check as
# you desire, such as limiting how far back the check will run, and so on.
use 5.016;
use warnings;
use strict;
use Getopt::Long;
use File::Basename;

my $PROG = basename($0);

sub show_usage {
    print STDERR <<END;
Usage: $PROG [options] -- [options and arguments to git-log] ...

This is a specialized extension of git, which can be used to help find a commit
to which a given mbox is applicable. The mbox is expected to be passed in via
standard input.

This works by parsing diff and index information from the patch
or series of patches, in order to determine what initial index it should check
for. By default it will search the entire history (each commit, going backwards
from HEAD). You may pass arguments to git-log which limit this search. Detailed
explanation of the various git-log options which may be useful here, is beyond
the scope of this usage output, however a few examples are provided below.

Examples:
; check only the most recent commit, and stop if it fails.
    git find-base -- -1 HEAD < "mbox-file"
; check the most recent commit of a branch
    git find-base -- -1 branch < "mbox-file"
; check commits between two branches
    git find-base -- master..devel < "mbox-file"

Essentially, the arguments are passed to generate a list of commit objects to
check, and you can use the powerful options in git-log to craft this list to
what you want to check against.

The tool works by checking index information, and will return the first commit
from git-log for which the mbox passed has matching initial index information.
This means that the mbox *will* apply cleanly to that patch, because it has
exact initial index as it expected. It does *not* require that the patch be
based exactly on the commit that was supplied, but only that the files it
modified are exactly what it thought.

Warnings and errors are printed to the standard error, and the only output to
standard out will be a single commit id. If nothing was found, no standard
output will be generated, and this utility will exit with a non-zero exit code.

Options:
    -?, -h      Show this text and exit.
END
}

# subroutine to check whether two blob indexes match, (ie: one
# contains the other regardless of which one is larger)
sub match_index {
    my ( $x, $y ) = @_;

    my $lx = length $x;
    my $ly = length $y;

    # Find which length is shortest
    my $l = $lx >= $ly ? $ly : $lx;

    # Truncate the indexes to the shortest
    my $tx = substr $lx,0,$l;
    my $ty = substr $ly,0,$l;

    # Return the match
    return $tx == $ty;
}

Getopt::Long::Configure("pass_through");
GetOptions('h|?' => sub { show_usage; exit 0; });

# Slurp the contents into $mbox for processing
my $mbox = do { local $/; <STDIN> };

# Hash of file-index relations
my %files = ();

# Split mbox apart by diff lines, preserving the filename we matched against,
# as well as the full index line. This should handle even the rename case from
# git diff output. Note, we assume that mbox has correct ordering of patches.
while ($mbox =~ /^diff --git [iwcoab]\/(?<oldfile>\S+) [iwcoab]\/(?<newfile>\S+)\n(?<new>new file mode [0-7]+\n)?(?<rename>^similarity index .*\n)?(?<from>^rename from \g{oldfile}\n)?(?<to>^rename to \g{newfile}\n)?(?<index>^index .*$)?\n/gm) {
    my $file = $+{oldfile};
    my $rename = $+{similarity};
    my $new = $+{new};
    my $index = $+{index};
    $file or die "Could not parse file from diff context.";

    # If we get a rename without an index, simply note that a file was renamed,
    # and ignore it, since there were no real changes.
    if ( $rename and not $index ) {
        print STDERR "Found rename of $file\n";
        next;
    }

    # Check the index line for proper formatting.
    $index =~ /^index ([0-9a-f]+)[.]{2}([0-9a-f]+) [0-7]{6}$/;
    my $initialshortblob = $1;
    my $modifiedshortblob = $2;
    $initialshortblob or die "Could not parse short blob index from diff context. Is the mbox corrupted?";

    # If we have a new file, store the initial setting as "new", and keep the
    # modified blob for checking future changes in this series.
    if ($new) {
        print STDERR "Found new file at $file\n";
        $files{$file}{"initial"} = "new";
        $files{$file}{"modified"} = $modifiedshortblob;
        next;
    };

    # If we already have this file, simply update the modified blob index
    if (exists $files{$file}) {
        # Check if the blob matches the last known result of the file
        if (match_index($initialshortblob, $files{$file}{"modified"})) {
            print STDERR "Found further modification of $file, ($initialshortblob -> $modifiedshortblob).\n";
            $files{$file}{"modified"} = $modifiedshortblob;
            next;
        } elsif (match_index($modifiedshortblob, $files{$file}{"modified"}) and match_index($initialshortblob, $files{$file}{"initial"})) {
            print STDERR "Found duplicate modification of $file. Possible duplicate patch blob, or an incorrect patch format? Ignoring for now.\n";
        } else {
            die "Found futher modification of $file that does not match expected index, ($initialshortblob -> $modifiedshortblob). Is the patch sequence out of order?";
        }
    }

    print STDERR "Found modification to $file, ($initialshortblob -> $modifiedshortblob).\n";

    # We have to process the short blob index into a full index value using
    # git-rev-parse, otherwise the lookup will fail.
    open my $rev_parse, '-|', 'git' => 'rev-parse' => '--verify', $initialshortblob
        or die "Couldn't open pipe to git-rev-parse: ", $!;

    my $initialblob = <$rev_parse>;
    close $rev_parse or die "Couldn't expand the blob index: ", $? >> 8;
    chomp $initialblob;

    # Store the initial blob, as well as the index after modification
    $files{$file}{"initial"} = $initialblob;
    $files{$file}{"modified"} = $modifiedshortblob;
}

# Subroutine to check a commit treeish, ensuring that every blob is present at
# the correct path. This allows us to determine whether the commit is "good",
# ie: has all the blobs required to cleanly apply the patch, or not.
sub check_commit {
    my ( $commit ) = @_;

    # Loop through every blob/path combination from the mbox, and check if the
    # ls-tree on that path matches the blob we need.
    for my $path ( keys %files) {
        my $blob = $files{$path}{"initial"};

        # We shouldn't try to find a new file, as it won't exist yet
        continue if $blob eq "new";

        # Fail with die on the pipe since this should always work.
        open my $ls_tree, '-|', 'git' => 'ls-tree' => '--full-tree' => $commit => '--', $path
            or die "Couldn't open pipe to git-ls-tree: ", $!;

        # Return here if we fail to find the file, because it might not yet
        # exist.
        my $tree = <$ls_tree>;
        close $ls_tree or do {
            print STDERR "Couldn't find matching tree: ", $? >> 8;
            return;
        };
        chomp $tree;

        # Check the output formatting to ensure we didn't get any errors
        $tree =~ /\A[0-7]{6} (\S+) (\S+)/ or do {
            print STDERR "Unexpected git-ls-tree output.\n";
            return;
        };

        # Return undef if they don't match. This will ensure we bail at the
        # first conflicting blob, without forcing extra checks.
        return if $2 ne $blob;
    }

    # If we get here, then everything matched above, so we can return true.
    return 1;
}

# Open the log pipe. Pass all of our ARGV directly to the log command
open my $log, '-|', git => log => @ARGV, '--pretty=format:%T %H'
    or die "Couldn't open pipe to git-log: ", $!;

# Loop through each commit in the log, checking if it's tree and hash have all
# the valid blobs. User can easily modify the log command via options to limit
# the scope, or reverse ordering. By default we find the most recent commit
# which has the required blobs.
while ( <$log> ) {
    chomp;
    my ($tree, $commit) = split " ", $_;

    if (check_commit $commit) {
        # Print the commit hash we found, and exit with a good return status.
        print "$commit\n";
        exit 0;
    }
}

# We failed to find a commit, so exit 1
print STDERR "Failed to find matching base commit.\n";
exit 1;
